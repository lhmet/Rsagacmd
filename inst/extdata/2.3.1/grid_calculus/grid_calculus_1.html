<h4>Tool</h4><table border="0"><tr><td valign="top"><b>Name</b></td><td valign="top">Grid Calculator</td></tr><tr><td valign="top"><b>ID</b></td><td valign="top">1</td></tr><tr><td valign="top"><b>Author</b></td><td valign="top">A.Ringeler (c) 2003</td></tr><tr><td valign="top"><b>Specification</b></td><td valign="top">grid</td></tr></table><hr><h4>Description</h4>The Grid Calculator calculates a new grid based on existing grids and a mathematical formula. The grid variables in the formula begin with the letter 'g' followed by a position index, which corresponds to the order of the grids in the input grid list (i.e.: g1, g2, g3, ... correspond to the first, second, third, ... grid in list). Grids from other systems than the default one can be addressed likewise using the letter 'h' (h1, h2, h3, ...), which correspond to the 'Grids from different Systems' list.

Example:	 sin(g1) * g2 + 2 * h1

The following operators are available for the formula definition:
<table border="0"><tr><td><b>+</b></td><td>Addition</td></tr><tr><td><b>-</b></td><td>Subtraction</td></tr><tr><td><b>*</b></td><td>Multiplication</td></tr><tr><td><b>/</b></td><td>Division</td></tr><tr><td><b>abs(x)</b></td><td>Absolute Value</td></tr><tr><td><b>mod(x, y)</b></td><td>Returns the floating point remainder of x/y</td></tr><tr><td><b>int(x)</b></td><td>Returns the integer part of floating point value x</td></tr><tr><td><b>sqr(x)</b></td><td>Square</td></tr><tr><td><b>sqrt(x)</b></td><td>Square Root</td></tr><tr><td><b>exp(x)</b></td><td>Exponential</td></tr><tr><td><b>pow(x, y)</b></td><td>Returns x raised to the power of y</td></tr><tr><td><b>x ^ y</b></td><td>Returns x raised to the power of y</td></tr><tr><td><b>ln(x)</b></td><td>Natural Logarithm</td></tr><tr><td><b>log(x)</b></td><td>Base 10 Logarithm</td></tr><tr><td><b>pi()</b></td><td>Returns the value of Pi</td></tr><tr><td><b>sin(x)</b></td><td>Sine</td></tr><tr><td><b>cos(x)</b></td><td>Cosine</td></tr><tr><td><b>tan(x)</b></td><td>Tangent</td></tr><tr><td><b>asin(x)</b></td><td>Arcsine</td></tr><tr><td><b>acos(x)</b></td><td>Arccosine</td></tr><tr><td><b>atan(x)</b></td><td>Arctangent</td></tr><tr><td><b>atan2(x, y)</b></td><td>Arctangent of x/y</td></tr><tr><td><b>gt(x, y)</b></td><td>Returns true (1), if x is greater than y, else false (0)</td></tr><tr><td><b>x > y</b></td><td>Returns true (1), if x is greater than y, else false (0)</td></tr><tr><td><b>lt(x, y)</b></td><td>Returns true (1), if x is less than y, else false (0)</td></tr><tr><td><b>x &lt; y</b></td><td>Returns true (1), if x is less than y, else false (0)</td></tr><tr><td><b>eq(x, y)</b></td><td>Returns true (1), if x equals y, else false (0)</td></tr><tr><td><b>x = y</b></td><td>Returns true (1), if x equals y, else false (0)</td></tr><tr><td><b>and(x, y)</b></td><td>Returns true (1), if both x and y are true (i.e. not 0)</td></tr><tr><td><b>or(x, y)</b></td><td>Returns true (1), if at least one of both x and y is true (i.e. not 0)</td></tr><tr><td><b>ifelse(c, x, y)</b></td><td>Returns x, if condition c is true (i.e. not 0), else y</td></tr><tr><td><b>rand_u(x, y)</b></td><td>Random number, uniform distribution with minimum x and maximum y</td></tr><tr><td><b>rand_g(x, y)</b></td><td>Random number, Gaussian distribution with mean x and standard deviation y</td></tr><tr><td><b>xpos(), ypos()</b></td><td>Get the x/y coordinates for the current cell</td></tr><tr><td><b>row(), col()</b></td><td>Get the current cell's column/row index</td></tr><tr><td><b>nodata()</b></td><td>Returns resulting grid's no-data value</td></tr></table><hr><h4>Parameters</h4><table border="1" width="100%" valign="top" cellpadding="5" rules="all"><tr><th>Name</th><th>Type</th><th>Identifier</th><th>Description</th><th>Constraints</th></tr>
<tr><th colspan="5">Input</th></tr><tr><td>Grids (*)</td><td>Grid list (optional input)</td><td>GRIDS</td><td>in the formula these grids are addressed in order of the list as 'g1, g2, g3, ...'</td><td></td></tr><tr><td>Grids from different Systems (*)</td><td>Grid list (optional input)</td><td>XGRIDS</td><td>in the formula these grids are addressed in order of the list as 'h1, h2, h3, ...'</td><td></td></tr><tr><th colspan="5">Output</th></tr><tr><td>Result</td><td>Grid (output)</td><td>RESULT</td><td></td><td></td></tr><tr><th colspan="5">Options</th></tr><tr><td>Resampling</td><td>Choice</td><td>RESAMPLING</td><td></td><td>Available Choices:
[0] Nearest Neighbour
[1] Bilinear Interpolation
[2] Bicubic Spline Interpolation
[3] B-Spline Interpolation
Default: 3</td></tr><tr><td>Formula</td><td>Text</td><td>FORMULA</td><td></td><td>Default: (g1 - g2) / (g1 + g2)</td></tr><tr><td>Name</td><td>Text</td><td>NAME</td><td></td><td>Default: Calculation</td></tr><tr><td>Take Formula</td><td>Boolean</td><td>FNAME</td><td></td><td>Default: 0</td></tr><tr><td>Use NoData</td><td>Boolean</td><td>USE_NODATA</td><td>Check this in order to include NoData cells in the calculation.</td><td>Default: 0</td></tr><tr><td>Data Type</td><td>Choice</td><td>TYPE</td><td></td><td>Available Choices:
[0] bit
[1] unsigned 1 byte integer
[2] signed 1 byte integer
[3] unsigned 2 byte integer
[4] signed 2 byte integer
[5] unsigned 4 byte integer
[6] signed 4 byte integer
[7] 4 byte floating point number
[8] 8 byte floating point number
Default: 7</td></tr></table>(*) <i>optional</i>