get_filename <- function(x) {
  terra::sources(x)$source
}

check_raster <- function(x) {
  inherits(x, "RasterLayer")
}


check_terra <- function(x) {
  inherits(x, "SpatRaster")
}


partial <- function(f, ...) {
  l <- list(...)
  function(...) {
    do.call(f, c(l, list(...)))
  }
}


check_grid_inputs <- function(x) {
  if (all(sapply(x, check_raster))) {
    backend <- "raster"
    
  } else if (all(sapply(x, check_terra))) {
    backend <- "terra"
    
  } else {
    msg <- paste(
      "inputs must consist exclusively of either RasterLayer or SpatRaster objects",
      "and not a combination of both"
    )
    rlang::abort(msg)
  }
  
  return(backend)
}


mosaic_raster <- function(x, filename, ...) {
  args <- list(...)
  
  names(x)[1:2] <- c('x', 'y')
  x$na.rm <- TRUE
  x$filename <- filename
  
  last <- function(x, na.rm = FALSE) x[length(x)]
  
  if (!"fun" %in% names(args))
    x$fun <- last
  
  if (length(args) > 0)
    x <- c(x, args)
  
  do.call(raster::mosaic, x)
}


process_tile_outputs <- function(output_tiles, backend, filename, args) {
  
  output_types <- sapply(output_tiles, class)
  
  # process results from tools with multiple outputs
  if (all(output_types == "list")) {
    n_grids <- sapply(output_tiles, length)[1]
    
    mosaicked_tiles <- list()
    
    for (idx in seq_len(n_grids)) {
      
      split_tiles <- lapply(output_tiles, function(tile) tile[[idx]])
      output_name <- names(output_tiles[[1]])[idx]
      
      filename_multi <- filename %>%
        tools::file_path_sans_ext() %>%
        paste(output_name, sep = "_") %>%
        paste(tools::file_ext(filename), sep = ".")
      
      if (backend == "raster") {
        obj <- rlang::exec(mosaic_raster, split_tiles, filename_multi, !!!args)
      }
      
      if (backend == "terra") {
        split_tile_filenames <- sapply(split_tiles, get_filename)
        raster_objs <- lapply(split_tile_filenames, raster::raster)
        obj <- rlang::exec(mosaic_raster, raster_objs, filename_multi, !!!args)
        obj <- terra::rast(obj)
      }
      mosaicked_tiles <- append(mosaicked_tiles, obj)
    }
    
    names(mosaicked_tiles) <- names(output_tiles[[1]])
    
  
  } else {
    
    if (backend == "raster") {
      mosaicked_tiles <- rlang::exec(mosaic_raster, output_tiles, filename, !!!args)
    }
    
    if (backend == "terra") {
      output_files <- sapply(output_tiles, get_filename)
      raster_objs <- lapply(output_files, raster::raster)
      mosaicked_tiles <- rlang::exec(mosaic_raster, raster_objs, filename, !!!args)
      mosaicked_tiles <- terra::rast(mosaicked_tiles)
    }
  }
  
  mosaicked_tiles
}


#' Apply a raster geoprocessing function to a list of raster data sets and
#' mosaic the results
#'
#' A 'purrr::map' style function to iterate over a list of datasets and apply a
#' geoprocessing tool to each input The output raster grids are mosaicked into a
#' new raster data set. The `map_raster` function can help to conveniently apply
#' terrain analysis tools to lists of datasets. One potential application is to
#' use tiling to handle raster datasets that are too large to fit into memory,
#' and when the
#' `saga_gis(grid_caching = TRUE)` option is too slow because caching in
#' SAGA-GIS only supports single-thread processing. The input tiles can
#' potentially generated using the `Rsagacmd::tile_geoprocessor` tool or other
#' functions that split a dataset into parts.
#'
#' @param .x A list of data sets to pass to the geoprocessing function.
#' @param .f A function or a formula that returns either a `RasterLayer` or
#'   `SpatRaster` raster object, depending on whether the inputs to the function
#'   are using the currently supported `raster` or `terra` backends.
#'   
#'   If .f is a  *function* then it is used as it.
#'   
#'   If .f is a *formula*, e.g. 
#'   `~ saga$ta_morphometry$terrain_ruggedness_index(dem = .x)` then it is
#'   converted to a function.
#'   \itemize{
#'   \item For a single argument to the function using `map_raster` then use `.x`.
#'   \item For two inputs to a function when using `map2_raster` then use `.x` and
#'   `.y`
#'   }
#' 
#'   Additional arguments are passed to the function using the `...`.
#' 
#'   A saga_cmd tool generated by `Rsagacmd::saga_gis()` can also be wrapped
#'   inside another function to fix arguments or select specific processing
#'   outputs, i.e. to remove non-raster based outputs that are also produced by
#'   a tool.
#' @param filename A character to optionally specify the path to save the final
#'   mosaicked result. If `filename = NULL` then `tempdir()` is used.
#' @param mosaic_opts Additional arguments to pass to the `raster::mosaic`
#'   function. This can include `fun = mean` to take the mean pixel value of
#'   overlapping areas, or another function. It can also include arguments which
#'   are passed to the `raster::writeRaster` function, such as `NAflag`,
#'   `options` etc.
#' @param ... Additional arguments to pass to `.f`.
#'
#' @return Either a `RasterLayer` or `SpatRaster` object depending on which
#'   package was used to provide the input to the `map_raster` function.
#' @export
#'
#' @examples
#' \dontrun{
#' library(Rsagacmd)
#' library(terra)
#' 
#' saga <- saga_gis(backend = "terra")
#' 
#' # generate a dem and split into tiles
#' dem <- saga$grid_calculus$random_terrain()
#' dem_tiles <- tile_geoprocessor(saga, dem, nx = 25, ny = 25)
#' 
#' # apply a saga tool function to each tile
#' tile_output <- map_raster(
#'     dem_tiles, 
#'     saga$ta_morphometry$terrain_ruggedness_index
#' )
#' 
#' # alternatively use a partial function to set arguments to the tool
#' tri_func <- function(dem) {
#'     saga$ta_morphometry$terrain_ruggedness_index(
#'         dem = dem, 
#'         radius = 7
#'      )
#' }
#' 
#' tile_output <- map_raster(dem_tiles, tri_func)
#' 
#' # if the saga tool produces multiple outputs then each output will be
#' # mosaicked automatically and returned as a list of raster datasets
#' tile_output <- map_raster(
#'     dem_tiles, 
#'     saga$ta_hydrology$saga_wetness_index
#' )
#' }
map_raster <- function(.x, .f, filename = NULL, mosaic_opts = NULL, ...) {
  args <- list(...)
  backend <- check_grid_inputs(.x)
  
  if (is.null(filename))
    filename <- tempfile(fileext = ".tif")
  
  if (inherits(.f, "formula")) {
    func <- attr(terms(.f), "term.labels")
    func <- rlang::parse_expr(func)
    .f <- function(.x) rlang::eval_tidy(func)
  }
  
  if (length(args) > 0)
    .f <- rlang::exec(partial, f = .f, !!!args)
  
  # apply function to each tile
  output_tiles <- pbapply::pblapply(.x, .f)
  
  mosaicked_tiles <-
    process_tile_outputs(output_tiles, backend, filename, mosaic_opts)
  
  mosaicked_tiles
}


#' @rdname map_raster
#' @export
map2_raster <- function(.x, .y, .f, filename = NULL, mosaic_opts = NULL, ...) {
  args <- list(...)
  backend <- check_grid_inputs(c(.x, .y))
  
  if (is.null(filename))
    filename <- tempfile(fileext = ".tif")
  
  if (inherits(.f, "formula")) {
    func <- attr(terms(.f), "term.labels")
    func <- rlang::parse_expr(func)
    .f <- function(.x, .y) rlang::eval_tidy(func)
  }
  
  if (length(args) > 0) 
    .f <- rlang::exec(partial, f = .f, !!!args)
  
  # apply function to each tile
  output_tiles <- pbapply::pbmapply(.f, .x, .y)
  
  mosaicked_tiles <-
    process_tile_outputs(output_tiles, backend, filename, mosaic_opts)
  
  mosaicked_tiles
}

