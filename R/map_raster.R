#' Apply a saga_cmd tool over over a list of raster datasets and mosaick the
#' results
#'
#' A `purrr::map` style function to iterate over a list of raster datasets and
#' apply a saga_cmd tool to each raster. The output grids are automatically
#' mosaicked into a new raster dataset. The `map_raster` function is can help
#' with conveniently applying terrain analysis functions to lists of rasters.
#' One potential application is using tiling to deal with raster datasets that
#' are too large to fit into memory, and when the
#' `saga_gis(grid_caching = TRUE)` option is too slow. The tiles can potentially
#' generated using the `Rsagacmd::tile_geoprocessor` tool, or other functions
#' that split a dataset.
#'
#' @param .x A list.
#' @param .f A saga_cmd function that was generated by `Rsagacmd::saga_gis()` to
#'   apply to each raster dataset in `.x`. The function can be used as it, such
#'   as `saga$ta_morphometry$terrain_ruggedness_index` or can be wrapped inside
#'   another as a partial function to set arguments to the tool or select
#'   specific tool outputs.
#' @param filename A character to optionally specify the path to save the final
#'   mosaicked result. If `filename = NULL` then `tempdir()` is used.
#' @param options A character vector of GDAL creation options used when saving
#'   the dataset, such as `options = c("COMPRESS=DEFLATE", "BIGTIFF=YES")`.
#' @param nodata Any number to use as the nodata value for the output raster. If
#'   `nodata = NULL` then the nodata value will be based on the input raster's
#'   nodata values.
#'
#' @return Either a `raster::RasterLayer` or `terra::SpatRaster` object.
#' @export
#'
#' @examples
#' \dontrun{
#' library(Rsagacmd)
#' library(terra)
#' 
#' saga <- saga_gis(backend = "terra")
#' 
#' # generate a dem and split into tiles
#' dem <- saga$grid_calculus$random_terrain()
#' dem_tiles <- tile_geoprocessor(saga, dem, nx = 25, ny = 25)
#' 
#' # apply a saga tool function to each tile
#' tile_output <- map_raster(
#'     dem_tiles, 
#'     saga$ta_morphometry$terrain_ruggedness_index
#' )
#' 
#' # alternatively use a partial function to set arguments to the tool
#' tri_func <- function(dem) {
#'     saga$ta_morphometry$terrain_ruggedness_index(
#'         dem = dem, 
#'         radius = 7
#'      )
#' }
#' 
#' tile_output <- map_raster(dem_tiles, tri_func)
#' 
#' # if the saga tool produces multiple outputs then each output will be
#' # mosaicked automatically and returned as a list of raster datasets
#' tile_output <- map_raster(
#'     dem_tiles, 
#'     saga$ta_hydrology$saga_wetness_index
#' )
#' }
map_raster <-
  function(.x,
           .f,
           filename = NULL,
           options = NULL,
           nodata = NULL) {
    
    # some checks on inputs
    if (all(purrr::map_lgl(.x, ~inherits(.x, "RasterLayer")))) {
      backend <- "raster"
    
    } else if (all(purrr::map_lgl(.x, ~inherits(.x, "SpatRaster")))) {
      backend <- "terra"
    
    } else {
      rlang::abort("`.x` must consist of a list of other RasterLayer or SpatRaster objects")
    }
    
    if (is.null(filename)) {
      filename <- tempfile(fileext = ".tif")
    }
    
    # build initial mosaic call
    mosaic_call <- rlang::call2(
      .fn = "mosaic_rasters", 
      .ns = "gdalUtils",
      output_Raster = TRUE,
      r = "nearest"
    )
    
    if (!is.null(options))
      mosaic_call <- rlang::call_modify(mosaic_call, options = options)
    
    if (!is.null(nodata))
      mosaic_call <- rlang::call_modify(mosaic_call, a_nodata = nodata)
    
    # apply function to each tile
    output_tiles <- purrr::map(.x, .f)
    
    # check if multiple outputs per tile are produced
    output_types <- purrr::map_chr(output_tiles, class)
    
    if (all(output_types == "list")) {
      n_grids <- purrr::map_int(output_tiles, length)[1]
      
      mosaicked_tiles <- list()
      
      for (idx in seq_len(n_grids)) {
        split_tiles <- purrr::map(output_tiles, function(tile) tile[[idx]])
        output_name <- names(output_tiles[[1]])[idx]
        
        filename_multi <- filename %>%
          tools::file_path_sans_ext() %>%
          paste(output_name, sep = "_") %>%
          paste(tools::file_ext(filename), sep = ".")
        
        if (backend == "raster")
          split_tile_filenames <- purrr::map_chr(split_tiles, raster::filename)
        if (backend == "terra")
          split_tile_filenames <- purrr::map_chr(split_tiles, ~ terra::sources(.x)$source)
        
        mosaic_call_multi <- rlang::call_modify(
          .call = mosaic_call, 
          gdalfile = split_tile_filenames,
          dst_dataset = filename_multi
        )
        obj <- rlang::eval_tidy(mosaic_call_multi)
        
        if (backend == "terra")
          obj <- terra::rast(obj)
        
        mosaicked_tiles <- append(mosaicked_tiles, obj)
      }
      
      names(mosaicked_tiles) <- names(output_tiles[[1]])
      
    } else {
      
      if (backend == "raster") {
        output_files <- purrr::map_chr(output_tiles, raster::filename)
      }
      if (backend == "terra") {
        output_files <- purrr::map_chr(output_tiles, ~ terra::sources(.x)$source)
      }
      
      mosaic_call <- rlang::call_modify(
        .call = mosaic_call, 
        gdalfile = output_files, 
        dst_dataset = filename
      )
      obj <- rlang::eval_tidy(mosaic_call)
      
      if (backend == "terra")
        mosaicked_tiles <- terra::rast(obj)
    }
    
    mosaicked_tiles
  }